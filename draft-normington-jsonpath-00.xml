<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.3.17 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="true"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="true"?>
<?rfc sortrefs="true"?>
<?rfc comments="yes"?>

<rfc ipr="trust200902" docName="draft-normington-jsonpath-00" category="std" consensus="true" submissionType="IETF" xml:lang="en" obsoletes="" updates="">

  <front>
    <title abbrev="JSONPath">JavaScript Object Notation (JSON) Path</title>

    <author initials="G." surname="Normington" fullname="Glyn Normington" role="editor">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Winchester</city>
          <region></region>
          <code></code>
          <country>UK</country>
        </postal>
        <phone></phone>
        <email>glyn.normington@gmail.com</email>
      </address>
    </author>
    <author initials="E." surname="Surov" fullname="Edward Surov" role="editor">
      <organization>TheSoul Publishing Ltd.</organization>
      <address>
        <postal>
          <street></street>
          <city>Limassol</city>
          <region></region>
          <code></code>
          <country>Cyprus</country>
        </postal>
        <phone></phone>
        <email>esurov.tsp@gmail.com</email>
      </address>
    </author>
    <author initials="M." surname="Mikulicic" fullname="Marko Mikulicic">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Pisa</city>
          <region></region>
          <code></code>
          <country>IT</country>
        </postal>
        <phone></phone>
        <email>mmikulicic@gmail.com</email>
      </address>
    </author>
    <author initials="S." surname="Gössner" fullname="Stefan Gössner">
      <organization>Fachhochschule Dortmund</organization>
      <address>
        <postal>
          <street>Sonnenstraße 96</street>
          <city>Dortmund</city>
          <code>D-44139</code>
          <country>Germany</country>
        </postal>
        <email>stefan.goessner@fh-dortmund.de</email>
      </address>
    </author>

    <date year="2020"/>

    <area>ART</area>
    <workgroup>JSONPath WG</workgroup>
    <keyword>JSON</keyword>

    <abstract>


<t>JSONPath defines a string syntax for identifying values
within a JavaScript Object Notation (JSON) document.</t>



    </abstract>


    <note title="">


<t><spanx style="strong">This document is a work in progress and has not yet been published
as an Internet Draft</spanx> (which needs to be fixed soon).</t>


    </note>


    <note title="Contributing">


<t>This document picks up the popular JSONPath specification dated
2007-02-21 and provides a normative definition for it.
In its current state, it is a strawman document showing what needs to
be covered.</t>

<t>Comments and issues can be directed at the github repository <spanx style="emph">insert
repo here</spanx> as well as (for the time when the more permanent home is
being decided) at the dispatch@ietf.org mailing list.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>This document picks up the popular JSONPath specification dated
2007-02-21 <xref target="JSONPath-orig"/> and provides a normative definition for it.
In its current state, it is a strawman document showing what needs to
be covered.</t>

<t>JSON is defined by <xref target="RFC8259"/>.</t>

<t>JSONPath is not intended as a replacement, but as a more powerful
companion, to JSON Pointer <xref target="RFC6901"/>. [insert reference to section
where the relationship is detailed.  The purposes of the two syntaxes
are different. Pointer is for isolating a single location within a
document. Path is a query syntax that can also be used to pull multiple locations.]</t>

<section anchor="terminology" title="Terminology">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

<t>The grammatical rules in this document are to be interpreted as ABNF,
as described in <xref target="RFC5234"/>.
ABNF terminal values in this document define Unicode code points rather than
their UTF-8 encoding.
For example, the Unicode PLACE OF INTEREST SIGN (U+2318) would be defined
in ABNF as <spanx style="verb">%x2318</spanx>.</t>

<t>The terminology of <xref target="RFC8259"/> applies.</t>

<t><list style="hanging">
  <t hangText="Data Item:">
  A structure complying to the generic data model of JSON, i.e.,
composed of containers such as arrays and maps (JSON objects), and
of atomic data such as null, true, false, numbers, and text strings.</t>
  <t hangText="Object:">
  Used in its generic sense, e.g., for programming language objects.
When a JSON Object as defined in <xref target="RFC8259"/> is meant, we specifically
say JSON Object.</t>
  <t hangText="Query:">
  Short name for JSONPath expression.</t>
  <t hangText="Argument:">
  Short name for the JSON data item a JSONPath expression is applied to.</t>
  <t hangText="Output Path:">
  A simple form of JSONPath expression that identifies a Position by
providing a query that results in exactly that position.  Similar
to, but syntactically different from, a JSON Pointer <xref target="RFC6901"/>.</t>
  <t hangText="Position:">
  A JSON data item identical to or nested within the JSON data item to
which the query is applied to, expressed either by the value of that
data item or by providing a JSONPath Output Path.</t>
</list></t>

</section>
<section anchor="inspired-by-xpath" title="Inspired by XPath">

<t>A frequently emphasized advantage of XML is the availability of
powerful tools to analyse, transform and selectively extract data from
XML documents.
<xref target="XPath"/> is one of these tools.</t>

<t>In 2007, the need for something solving the same class of problems for
the emerging JSON community became apparent, specifically for:</t>

<t><list style="symbols">
  <t>Finding data interactively and extracting them out of <xref target="RFC8259"/>
data items without special scripting.</t>
  <t>Specifying the relevant parts of the JSON data in a request by a
client, so the server can reduce the amount of data in its response,
minimizing bandwidth usage.</t>
</list></t>

<t>So what does such a tool look like for JSON?
When defining a JSONPath, how should expressions look?</t>

<t>The XPath expression</t>

<figure><artwork><![CDATA[
/store/book[1]/title
]]></artwork></figure>

<t>looks like</t>

<figure><artwork><![CDATA[
x.store.book[0].title
]]></artwork></figure>

<t>or</t>

<figure><artwork><![CDATA[
x['store']['book'][0]['title']
]]></artwork></figure>

<t>in popular programming languages such as JavaScript, Python and PHP,
with a variable x holding the JSON data item.  Here we observe that
such languages already have a fundamentally XPath-like feature built
in.</t>

<t>The JSONPath tool in question should:</t>

<t><list style="symbols">
  <t>be naturally based on those language characteristics.</t>
  <t>cover only essential parts of XPath 1.0.</t>
  <t>be lightweight in code size and memory consumption.</t>
  <t>be runtime efficient.</t>
</list></t>

</section>
<section anchor="overview-of-jsonpath-expressions" title="Overview of JSONPath Expressions">

<t>JSONPath expressions always apply to a JSON data item in the same way
as XPath expressions are used in combination with an XML document.
Since a JSON data item is usually anonymous and doesn't necessarily
have a "root member object", JSONPath used the abstract name <spanx style="verb">$</spanx> to
refer to the top level object of the data item.</t>

<t>JSONPath expressions can use the <spanx style="emph">dot–notation</spanx></t>

<figure><artwork><![CDATA[
$.store.book[0].title
]]></artwork></figure>

<t>or the <spanx style="emph">bracket–notation</spanx></t>

<figure><artwork><![CDATA[
$['store']['book'][0]['title']
]]></artwork></figure>

<t>for paths input to a JSONPath processor.
[1]
Where a JSONPath processor uses JSONPath expressions as output paths,
these will always be converted to the more general <spanx style="emph">bracket–notation</spanx>.
[2]
Bracket notation is more general than dot notation and can serve as a
canonical form when a JSONPath processor uses JSONPath expressions as
output paths.</t>

<t>JSONPath allows the wildcard symbol <spanx style="verb">*</spanx> for member names and array
indices. It borrows the descendant operator <spanx style="verb">..</spanx> from <xref target="E4X"/> and
the array slice syntax proposal <spanx style="verb">[start:end:step]</spanx> <xref target="SLICE"/> from ECMASCRIPT 4.</t>

<t>JSONPath was originally designed to employ an <spanx style="emph">underlying scripting
language</spanx> for computing expressions.  The present specification
defines a simple expression language that is independent from any
scripting language in use on the platform.</t>

<t>JSONPath can use expressions, written in parentheses: <spanx style="verb">(&lt;expr&gt;)</spanx>, as
an alternative to explicit names or indices as in:</t>

<figure><artwork><![CDATA[
$.store.book[(@.length-1)].title
]]></artwork></figure>

<t>The symbol <spanx style="verb">@</spanx> is used for the current object.
Filter expressions are supported via the syntax <spanx style="verb">?(&lt;boolean expr&gt;)</spanx> as in</t>

<figure><artwork><![CDATA[
$.store.book[?(@.price < 10)].title
]]></artwork></figure>

<t>Here is a complete overview and a side by side comparison of the JSONPath syntax elements with their XPath counterparts.</t>

<texttable title="Overview over JSONPath, comparing to XPath" anchor="tbl-overview">
      <ttcol align='left'>XPath</ttcol>
      <ttcol align='left'>JSONPath</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c><spanx style="verb">/</spanx></c>
      <c><spanx style="verb">$</spanx></c>
      <c>the root object/element</c>
      <c><spanx style="verb">.</spanx></c>
      <c><spanx style="verb">@</spanx></c>
      <c>the current object/element</c>
      <c><spanx style="verb">/</spanx></c>
      <c><spanx style="verb">.</spanx> or <spanx style="verb">[]</spanx></c>
      <c>child operator</c>
      <c><spanx style="verb">..</spanx></c>
      <c>n/a</c>
      <c>parent operator</c>
      <c><spanx style="verb">//</spanx></c>
      <c><spanx style="verb">..</spanx></c>
      <c>nested descendants (JSONPath borrows this syntax from E4X)</c>
      <c><spanx style="verb">*</spanx></c>
      <c><spanx style="verb">*</spanx></c>
      <c>wildcard: All objects/elements regardless of their names</c>
      <c><spanx style="verb">@</spanx></c>
      <c>n/a</c>
      <c>attribute access: JSON data items do not have attributes</c>
      <c><spanx style="verb">[]</spanx></c>
      <c><spanx style="verb">[]</spanx></c>
      <c>subscript operator: XPath uses it to iterate over element collections and for predicates; native array indexing as in JavaScript here</c>
      <c><spanx style="verb">¦</spanx></c>
      <c><spanx style="verb">[,]</spanx></c>
      <c>Union operator in XPath (results in a combination of node sets); JSONPath allows alternate names or array indices as a set</c>
      <c>n/a</c>
      <c><spanx style="verb">[start:end:step]</spanx></c>
      <c>array slice operator borrowed from ES4</c>
      <c><spanx style="verb">[]</spanx></c>
      <c><spanx style="verb">?()</spanx></c>
      <c>applies a filter (script) expression</c>
      <c>n/a</c>
      <c><spanx style="verb">()</spanx></c>
      <c>expression engine</c>
      <c><spanx style="verb">()</spanx></c>
      <c>n/a</c>
      <c>grouping in Xpath</c>
</texttable>

<!-- note that the weirdness about the vertical bar above is intentional -->

<t>XPath has a lot more to offer (location paths in unabbreviated syntax,
operators and functions) than listed here.  Moreover there is a
significant difference how the subscript operator works in Xpath and
JSONPath:</t>

<t><list style="symbols">
  <t>Square brackets in XPath expressions always operate on the <spanx style="emph">node set</spanx> resulting from the previous path fragment. Indices always start at 1.</t>
  <t>With JSONPath, square brackets operate on the <spanx style="emph">object</spanx> or <spanx style="emph">array</spanx>
addressed by the previous path fragment. Array indices always start at 0.</t>
</list></t>

</section>
</section>
<section anchor="jsonpath-examples" title="JSONPath Examples">

<t>This section provides some more examples for JSONPath expressions.
The examples are based on a simple JSON data item patterned after a
typical XML example representing a bookstore (that also has bicycles):</t>

<figure title="Example JSON data item"><artwork type="json"><![CDATA[
{ "store": {
    "book": [
      { "category": "reference",
        "author": "Nigel Rees",
        "title": "Sayings of the Century",
        "price": 8.95
      },
      { "category": "fiction",
        "author": "Evelyn Waugh",
        "title": "Sword of Honour",
        "price": 12.99
      },
      { "category": "fiction",
        "author": "Herman Melville",
        "title": "Moby Dick",
        "isbn": "0-553-21311-3",
        "price": 8.99
      },
      { "category": "fiction",
        "author": "J. R. R. Tolkien",
        "title": "The Lord of the Rings",
        "isbn": "0-395-19395-8",
        "price": 22.99
      }
    ],
    "bicycle": {
      "color": "red",
      "price": 19.95
    }
  }
}
]]></artwork></figure>

<t>The examples in <xref target="tbl-example"/> use the expression mechanism to obtain
the number of items in an array, to test for the presence of a map
member, and to perform numeric comparisons of map member values with a
constant.</t>

<texttable title="Example JSONPath expressions applied to the example JSON data item" anchor="tbl-example">
      <ttcol align='left'>XPath</ttcol>
      <ttcol align='left'>JSONPath</ttcol>
      <ttcol align='left'>Result</ttcol>
      <c><spanx style="verb">/store/book/author</spanx></c>
      <c><spanx style="verb">$.store.book[*].author</spanx></c>
      <c>the authors of all books in the store</c>
      <c><spanx style="verb">//author</spanx></c>
      <c><spanx style="verb">$..author</spanx></c>
      <c>all authors</c>
      <c><spanx style="verb">/store/*</spanx></c>
      <c><spanx style="verb">$.store.*</spanx></c>
      <c>all things in store, which are some books and a red bicycle</c>
      <c><spanx style="verb">/store//price</spanx></c>
      <c><spanx style="verb">$.store..price</spanx></c>
      <c>the prices of everything in the store</c>
      <c><spanx style="verb">//book[3]</spanx></c>
      <c><spanx style="verb">$..book[2]</spanx></c>
      <c>the third book</c>
      <c><spanx style="verb">//book[last()]</spanx></c>
      <c><spanx style="verb">$..book[(@.length-1)]</spanx><br /><spanx style="verb">$..book[-1]</spanx></c>
      <c>the last book in order</c>
      <c><spanx style="verb">//book[position()&lt;3]</spanx></c>
      <c><spanx style="verb">$..book[0,1]</spanx><br /><spanx style="verb">$..book[:2]</spanx></c>
      <c>the first two books</c>
      <c><spanx style="verb">//book[isbn]</spanx></c>
      <c><spanx style="verb">$..book[?(@.isbn)]</spanx></c>
      <c>filter all books with isbn number</c>
      <c><spanx style="verb">//book[price&lt;10]</spanx></c>
      <c><spanx style="verb">$..book[?(@.price&lt;10)]</spanx></c>
      <c>filter all books cheaper than 10</c>
      <c><spanx style="verb">//*</spanx></c>
      <c><spanx style="verb">$..*</spanx></c>
      <c>all elements in XML document; all members of JSON data item</c>
</texttable>

<!-- back to normington draft; not yet merged up where needed (e.g., terminology). -->

</section>
<section anchor="jsonpath-syntax-and-semantics" title="JSONPath Syntax and Semantics">

<section anchor="overview" title="Overview">

<t>A JSONPath is a string which selects zero or more nodes of a piece of JSON.
A valid JSONPath conforms to the ABNF syntax defined by this document.</t>

<t>A JSONPath MUST be encoded using UTF-8. To parse a JSONPath according to
the grammar in this document, its UTF-8 form SHOULD first be decoded into
Unicode code points as described
in <xref target="RFC3629"/>.</t>

</section>
<section anchor="terminology-1" title="Terminology">

<t>A JSON value is logically a tree of nodes.</t>

<t>Each node holds a JSON value (as defined by <xref target="RFC8259"/>) of one of the
types object, array, number, string, or one of the literals <spanx style="verb">true</spanx>,
<spanx style="verb">false</spanx>, or <spanx style="verb">null</spanx>.
The type of the JSON value held by a node is
sometimes referred to as the type of the node.</t>

</section>
<section anchor="implementation" title="Implementation">

<t>An implementation of this specification, from now on referred to simply as
"an implementation", SHOULD takes two inputs, a JSONPath and a JSON value,
and produce
a possibly empty list of nodes of the JSON value which are selected by
the JSONPath or an error (but not both).</t>

<t>If no node is selected and no error has occurred, an implementation MUST
return an empty list of nodes.</t>

<t>Syntax errors in the JSONPath SHOULD be detected before selection is attempted
since these errors do not depend on the JSON value.
Therefore, an implementation SHOULD take a JSONPath and produce an optional
syntax error and then,
if and only if an error was not produced, SHOULD take a JSON value and
produce a list of nodes or an error (but not both).</t>

<t>Alternatively, an implementation MAY take a JSONPath and a JSON value
and produce a list of nodes or an optional error (but not both).</t>

<t>For any implementation, if a syntactically invalid JSONPath is provided,
the implementation MUST return an error.</t>

<t>If a syntactially invalid JSON value is provided, any implementation SHOULD
return an error.</t>

</section>
<section anchor="syntax" title="Syntax">

<t>Syntactically, a JSONPath consists of a root selector (<spanx style="verb">$</spanx>), which
selects the root node of a JSON value, followed by a possibly empty
sequence of <spanx style="emph">selectors</spanx>.</t>

<figure><artwork type="abnf"><![CDATA[
json-path = root-selector *selector
root-selector = %x24               ; $ selects document root node
]]></artwork></figure>

<t>The syntax and semantics of each selector is defined below.</t>

</section>
<section anchor="semantics" title="Semantics">

<t>The root selector <spanx style="verb">$</spanx> not only selects the root node of the input
document, but it also produces as output a list consisting of one
node: the input document.</t>

<t>A selector may select zero or more nodes for further processing.
A syntactically valid selector MUST NOT produce errors.
This means that some
operations which might be considered erroneous, such as indexing beyond the
end of an array,
simply result in fewer nodes being selected.</t>

<t>But a selector doesn't just act on a single node: each selector acts on a
list of nodes and produces a list of nodes, as follows.</t>

<t>After the root selector, the remainder of the JSONPath is processed by passing
lists of nodes from one selector to the next ending up with a list of nodes
which is the result of
applying the JSONPath to the input JSON value.</t>

<t>Each selector acts on its input list of nodes as follows.
For each node in
the list, the selector selects zero or more nodes, each of which is a descendant
of the node or the node itself.
The output list of nodes of a selector is the concatenation of the lists
of selected nodes for each input node.</t>

<t>A specific, non-normative example will make this clearer.
Suppose the input
document is: <spanx style="verb">{"a":[{"b":0},{"b":1},{"c":2}]}</spanx>.
As we will see later, the JSONPath <spanx style="verb">$.a[*].b</spanx> selects the following list of nodes: <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>.
Let's walk through this in detail.</t>

<t>The JSONPath consists of <spanx style="verb">$</spanx> followed by three selectors: <spanx style="verb">.a</spanx>, <spanx style="verb">[*]</spanx>, and <spanx style="verb">.b</spanx>.</t>

<t>Firstly, <spanx style="verb">$</spanx> selects the root node which is the input document.
So the result is a list
consisting of just the root node.</t>

<t>Next, <spanx style="verb">.a</spanx> selects from any input node of type object and selects any value of the input
node corresponding to the key <spanx style="verb">"a"</spanx>.
The result is again a list of one node: <spanx style="verb">[{"b":0},{"b":1},{"c":2}]</spanx>.</t>

<t>Next, <spanx style="verb">[*]</spanx> selects from any input node which is an array and selects all the elements
of the input node.
The result is a list of three nodes: <spanx style="verb">{"b":0}</spanx>, <spanx style="verb">{"b":1}</spanx>, and <spanx style="verb">{"c":2}</spanx>.</t>

<t>Finally, <spanx style="verb">.b</spanx> selects from any input node of type object with a key
<spanx style="verb">b</spanx> and selects the value of the input node corresponding to that key.
The result is a list containing <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>.
This is the concatenation of three lists, two of length one containing <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>, respectively, and one of length zero.</t>

<t>As a consequence of this approach, if any of the selectors selects no nodes,
then the whole JSONPath selects no nodes.</t>

<t>In what follows, the semantics of each selector are defined for each type
of node.</t>

</section>
<section anchor="selectors" title="Selectors">

<section anchor="dot-child-selector" title="Dot Child Selector">

<section numbered="false" toc="exclude" anchor="syntax-1" title="Syntax">

<t>A dot child selector has a key known as a dot child name or a single asterisk
(<spanx style="verb">*</spanx>).</t>

<t>A dot child name corresponds to a name in a JSON object.</t>

<figure><artwork type="abnf"><![CDATA[
selector = dot-child              ; see below for alternatives
dot-child = %x2E dot-child-name / ; .<dot-child-name>
            %x2E %x2A             ; .*
dot-child-name = 1*(
                   %x2D /         ; -
                   DIGIT /
                   ALPHA /
                   %x5F /         ; _
                   %x80-10FFFF    ; any non-ASCII Unicode character
                 )
DIGIT =  %x30-39                  ; 0-9
ALPHA = %x41-5A / %x61-7A         ; A-Z / a-z
]]></artwork></figure>

<t>More general child names, such as the empty string, are supported by "Union
Child" (<xref target="unionchild" format="default"/>).</t>

<t>Note that the <spanx style="verb">dot-child-name</spanx> rule follows the philosophy of JSON strings and is
allowed to contain bit sequences that cannot encode Unicode characters (a
single unpaired UTF-16 surrogate, for example).
The behaviour of an implementation is undefined for child names which do
not encode Unicode characters.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-1" title="Semantics">

<t>A dot child name which is not a single asterisk (<spanx style="verb">*</spanx>) is considered to have a key.
It selects the value corresponding to the key from any object node.
It selects
no nodes from a node which is not an object.</t>

<t>The key of a dot child name is the sequence of Unicode characters contained
in that name.</t>

<t>A dot child name consisting of a single asterisk is a wild card. It selects
all the values of any object node.
It also selects all the elements of any array node.
It selects no nodes from
number, string, or literal nodes.</t>

</section>
</section>
<section anchor="union-selector" title="Union Selector">

<section anchor="syntax-2" title="Syntax">

<t>A union selector consists of one or more union elements.</t>

<figure><artwork type="abnf"><![CDATA[
selector =/ union
union = %x5B ws union-elements ws %x5D ; [...]
ws = *%x20                             ; zero or more spaces
union-elements = union-element /
                 union-element ws %x2C ws union-elements
                                       ; ,-separated list
]]></artwork></figure>

</section>
<section anchor="semantics-2" title="Semantics">

<t>A union selects any node which is selected by at least one of the union selectors
and selects the concatenation of the
lists (in the order of the selectors) of nodes selected by the union elements.<!--  TODO: define whether duplicates are kept or removed.  --></t>

</section>
<section anchor="unionchild" title="Child">

<section numbered="false" toc="exclude" anchor="syntax-3" title="Syntax">

<t>A child is a quoted string.</t>

<figure><artwork type="abnf"><![CDATA[
union-element = child ; see below for more alternatives
child = %x22 *double-quoted %x22 / ; "string"
        %x27 *single-quoted %x27   ; 'string'

double-quoted = dq-unescaped /
          escape (
              %x22 /          ; "    quotation mark  U+0022
              %x2F /          ; /    solidus         U+002F
              %x5C /          ; \    reverse solidus U+005C
              %x62 /          ; b    backspace       U+0008
              %x66 /          ; f    form feed       U+000C
              %x6E /          ; n    line feed       U+000A
              %x72 /          ; r    carriage return U+000D
              %x74 /          ; t    tab             U+0009
              %x75 4HEXDIG )  ; uXXXX                U+XXXX


      dq-unescaped = %x20-21 / %x23-5B / %x5D-10FFFF

single-quoted = sq-unescaped /
          escape (
              %x27 /          ; '    apostrophe      U+0027
              %x2F /          ; /    solidus         U+002F
              %x5C /          ; \    reverse solidus U+005C
              %x62 /          ; b    backspace       U+0008
              %x66 /          ; f    form feed       U+000C
              %x6E /          ; n    line feed       U+000A
              %x72 /          ; r    carriage return U+000D
              %x74 /          ; t    tab             U+0009
              %x75 4HEXDIG )  ; uXXXX                U+XXXX

      sq-unescaped = %x20-26 / %x28-5B / %x5D-10FFFF

escape = %x5C                 ; \

HEXDIG =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
                              ; case insensitive hex digit
]]></artwork></figure>

<t>Notes:
1. double-quoted strings follow JSON in <xref target="RFC8259"/>.
   Single-quoted strings follow an analogous pattern.
2. <spanx style="verb">HEXDIG</spanx> includes A-F and a-f.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-3" title="Semantics">

<t>If the child is a quoted string, the string MUST be converted to a
key by removing the surrounding quotes and
replacing each escape sequence with its equivalent Unicode character, as
in the table below:</t>

<texttable title="Escape Sequence Replacements">
      <ttcol align='center'>Escape Sequence</ttcol>
      <ttcol align='center'>Unicode Character</ttcol>
      <c>%x5C %x22</c>
      <c>U+0022</c>
      <c>%x5C %x27</c>
      <c>U+0027</c>
      <c>%x5C %x2F</c>
      <c>U+002F</c>
      <c>%x5C %x5C</c>
      <c>U+005C</c>
      <c>%x5C %x62</c>
      <c>U+0008</c>
      <c>%x5C %x66</c>
      <c>U+000C</c>
      <c>%x5C %x6E</c>
      <c>U+000A</c>
      <c>%x5C %x72</c>
      <c>U+000D</c>
      <c>%x5C %x74</c>
      <c>U+0009</c>
      <c>%x5C uXXXX</c>
      <c>U+XXXX</c>
</texttable>

<t>The child selects the value corresponding to the key from any object
node with the key as a name.
It selects no nodes from a node which is not an object.</t>

</section>
</section>
<section anchor="array-selector" title="Array Selector">

<section numbered="false" toc="exclude" anchor="syntax-4" title="Syntax">

<t>An array selector selects zero or more elements of an array node.
An array selector takes the form of an index, which selects at most one element,
or a slice, which selects zero or more elements.</t>

<figure><artwork type="abnf"><![CDATA[
union-element =/ array-index / array-slice
]]></artwork></figure>

<t>An array index is an integer (in base 10).</t>

<figure><artwork type="abnf"><![CDATA[
array-index = integer

integer = ["-"] ("0" / (DIGIT1 *DIGIT))
                            ; optional - followed by 0 or
                            ; sequence of digits with no leading zero
DIGIT1 = %x31-39            ; non-zero digit
]]></artwork></figure>

<t>Note: the syntax does not allow integers with leading zeros such as <spanx style="verb">01</spanx> and <spanx style="verb">-01</spanx>.</t>

<t>An array slice consists of three optional integers (in base 10) separated by colons.</t>

<figure><artwork type="abnf"><![CDATA[
array-slice = [ start ] ws ":" ws [ end ]
                   [ ws ":" ws [ step ] ]
start = integer
end = integer
step = integer
]]></artwork></figure>

<t>Note: the array slices <spanx style="verb">:</spanx> and <spanx style="verb">::</spanx> are both syntactically valid, as are <spanx style="verb">:2:2</spanx>, <spanx style="verb">2::2</spanx>, and <spanx style="verb">2:4:</spanx>.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-4" title="Semantics">

<section numbered="false" toc="exclude" anchor="informal-introduction" title="Informal Introduction">

<t>This section is non-normative.</t>

<t>Array indexing is a way of selecting a particular element of an array using
a 0-based index.
For example, the expression <spanx style="verb">[0]</spanx> selects the first element of a non-empty array.</t>

<t>Negative indices index from the end of an array.
For example, the expression <spanx style="verb">[-2]</spanx> selects the last but one element of an array with at least two elements.</t>

<t>Array slicing is inspired by the behaviour of the <spanx style="verb">Array.prototype.slice</spanx> method
of the JavaScript language as defined by the ECMA-262 standard <xref target="ECMA-262"/>,
with the addition of the <spanx style="verb">step</spanx> parameter, which is inspired by the Python slice expression.</t>

<t>The array slice expression <spanx style="verb">[start:end:step]</spanx> selects elements at indices starting at <spanx style="verb">start</spanx>,
incrementing by <spanx style="verb">step</spanx>, and ending with <spanx style="verb">end</spanx> (which is itself excluded).
So, for example, the expression <spanx style="verb">[1:3]</spanx> (where <spanx style="verb">step</spanx> defaults to <spanx style="verb">1</spanx>)
selects elements with indices <spanx style="verb">1</spanx> and <spanx style="verb">2</spanx> (in that order) whereas
<spanx style="verb">[1:5:2]</spanx> selects elements with indices <spanx style="verb">1</spanx> and <spanx style="verb">3</spanx>.</t>

<t>When <spanx style="verb">step</spanx> is negative, elements are selected in reverse order. Thus,
for example, <spanx style="verb">[5:1:-2]</spanx> selects elements with indices <spanx style="verb">5</spanx> and <spanx style="verb">3</spanx>, in
that order and <spanx style="verb">[::-1]</spanx> selects all the elements of an array in
reverse order.</t>

<t>When <spanx style="verb">step</spanx> is <spanx style="verb">0</spanx>, no elements are selected.
This is the one case which differs from the behaviour of Python, which
raises an error in this case.</t>

<t>The following section specifies the behaviour fully, without depending on
JavaScript or Python behaviour.</t>

</section>
<section numbered="false" toc="exclude" anchor="detailed-semantics" title="Detailed Semantics">

<t>An array selector is either an array slice or an array index, which is defined
in terms of an array slice.</t>

<t>A slice expression selects a subset of the elements of the input array, in
the same order
as the array or the reverse order, depending on the sign of the <spanx style="verb">step</spanx> parameter.
It selects no nodes from a node which is not an array.</t>

<t>A slice is defined by the two slice parameters, <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx>, and
an iteration delta, <spanx style="verb">step</spanx>.
Each of these parameters is
optional. <spanx style="verb">len</spanx> is the length of the input array.</t>

<t>The default value for <spanx style="verb">step</spanx> is <spanx style="verb">1</spanx>.
The default values for <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> depend on the sign of <spanx style="verb">step</spanx>,
as follows:</t>

<texttable title="Default array slice start and end values">
      <ttcol align='left'>Condition</ttcol>
      <ttcol align='left'>start</ttcol>
      <ttcol align='left'>end</ttcol>
      <c>step &gt;= 0</c>
      <c>0</c>
      <c>len</c>
      <c>step &lt; 0</c>
      <c>len - 1</c>
      <c>-len - 1</c>
</texttable>

<t>Slice expression parameters <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> are not directly usable
as slice bounds and must first be normalized. Normalization is defined as:</t>

<figure><artwork><![CDATA[
FUNCTION Normalize(i):
  IF i >= 0 THEN
    RETURN i
  ELSE
    RETURN len + i
  END IF
]]></artwork></figure>

<t>The result of the array indexing expression <spanx style="verb">[i]</spanx> is defined to be the result of the array
slicing expression <spanx style="verb">[i:Normalize(i)+1:1]</spanx>.</t>

<t>Slice expression parameters <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> are used to derive slice bounds <spanx style="verb">lower</spanx> and <spanx style="verb">upper</spanx>.
The direction of the iteration, defined
by the sign of <spanx style="verb">step</spanx>, determines which of the parameters is the lower bound and which
is the upper bound:</t>

<figure><artwork><![CDATA[
FUNCTION Bounds(start, end, step, len):
  n_start = Normalize(start)
  n_end = Normalize(end)

  IF step >= 0 THEN
    lower = MIN(MAX(n_start, 0), len)
    upper = MIN(MAX(n_end, 0), len)
  ELSE
    upper = MIN(MAX(n_start, -1), len-1)
    lower = MIN(MAX(n_end, -1), len-1)
  END IF

  RETURN (lower, upper)
]]></artwork></figure>

<t>The slice expression selects elements with indices between the lower and
upper bounds.
In the following pseudocode, the <spanx style="verb">a(i)</spanx> construct expresses the
0-based indexing operation on the underlying array.</t>

<figure><artwork><![CDATA[
IF step > 0 THEN

  i = lower
  WHILE i < upper:
    SELECT a(i)
    i = i + step
  END WHILE

ELSE if step < 0 THEN

  i = upper
  WHILE lower < i:
    SELECT a(i)
    i = i + step
  END WHILE

END IF
]]></artwork></figure>

<t>When <spanx style="verb">step = 0</spanx>, no elements are selected and the result array is empty.</t>

<t>An implementation MUST raise an error if any of the slice expression parameters
does not fit in
the implementation's representation of an integer.
If a successfully parsed slice expression is evaluated against an array whose
size doesn't
fit in the implementation's representation of an integer, the implementation
MUST raise an error.</t>

</section>
</section>
</section>
</section>
</section>
</section>
<section anchor="IANA" title="IANA Considerations">

<t>TBD: Define a media type for JSON Path expressions.</t>

</section>
<section anchor="Security" title="Security Considerations">

<t>This section gives security considerations, as required by <xref target="RFC3552"/>.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC3629" target='https://www.rfc-editor.org/info/rfc3629'>
<front>
<title>UTF-8, a transformation format of ISO 10646</title>
<author initials='F.' surname='Yergeau' fullname='F. Yergeau'><organization /></author>
<date year='2003' month='November' />
<abstract><t>ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t></abstract>
</front>
<seriesInfo name='STD' value='63'/>
<seriesInfo name='RFC' value='3629'/>
<seriesInfo name='DOI' value='10.17487/RFC3629'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC8259" target='https://www.rfc-editor.org/info/rfc8259'>
<front>
<title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
<author initials='T.' surname='Bray' fullname='T. Bray' role='editor'><organization /></author>
<date year='2017' month='December' />
<abstract><t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.</t><t>This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t></abstract>
</front>
<seriesInfo name='STD' value='90'/>
<seriesInfo name='RFC' value='8259'/>
<seriesInfo name='DOI' value='10.17487/RFC8259'/>
</reference>



<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor="RFC3552" target='https://www.rfc-editor.org/info/rfc3552'>
<front>
<title>Guidelines for Writing RFC Text on Security Considerations</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<author initials='B.' surname='Korver' fullname='B. Korver'><organization /></author>
<date year='2003' month='July' />
<abstract><t>All RFCs are required to have a Security Considerations section. Historically, such sections have been relatively weak.  This document provides guidelines to RFC authors on how to write a good Security Considerations section.   This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='72'/>
<seriesInfo name='RFC' value='3552'/>
<seriesInfo name='DOI' value='10.17487/RFC3552'/>
</reference>



<reference  anchor="RFC6901" target='https://www.rfc-editor.org/info/rfc6901'>
<front>
<title>JavaScript Object Notation (JSON) Pointer</title>
<author initials='P.' surname='Bryan' fullname='P. Bryan' role='editor'><organization /></author>
<author initials='K.' surname='Zyp' fullname='K. Zyp'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<date year='2013' month='April' />
<abstract><t>JSON Pointer defines a string syntax for identifying a specific value within a JavaScript Object Notation (JSON) document.</t></abstract>
</front>
<seriesInfo name='RFC' value='6901'/>
<seriesInfo name='DOI' value='10.17487/RFC6901'/>
</reference>


<reference anchor="JSONPath-orig" target="https://goessner.net/articles/JsonPath/">
  <front>
    <title>JSONPath – XPath for JSON</title>
    <author initials="S." surname="Gössner" fullname="Stefan Gössner">
      <organization>Fachhochschule Dortmund</organization>
    </author>
    <date year="2007" month="February" day="21"/>
  </front>
</reference>




<reference anchor="XPath"
           target='https://www.w3.org/TR/2010/REC-xpath20-20101214'>
<front>
<title>XML Path Language (XPath) 2.0 (Second Edition)</title>

<author initials='A.' surname='Berglund' fullname='Anders Berglund'>
    <organization />
</author>

<author initials='S.' surname='Boag' fullname='Scott Boag'>
    <organization />
</author>

<author initials='D.' surname='Chamberlin' fullname='Don Chamberlin'>
    <organization />
</author>

<author initials='M.' surname='Fernandez' fullname='Mary Fernandez'>
    <organization />
</author>

<author initials='M.' surname='Kay' fullname='Michael Kay'>
    <organization />
</author>

<author initials='J.' surname='Robie' fullname='Jonathan Robie'>
    <organization />
</author>

<author initials='J.' surname='Simeon' fullname='Jerome Simeon'>
    <organization />
</author>

<date month='December' day='14' year='2010' />
</front>

<seriesInfo name='World Wide Web Consortium Recommendation' value='REC-xpath20-20101214' />
<format type='HTML' target='https://www.w3.org/TR/2010/REC-xpath20-20101214' />
</reference>


<reference anchor="E4X" >
  <front>
    <title>Information technology — ECMAScript for XML (E4X) specification</title>
    <author >
      <organization>ISO</organization>
    </author>
    <date year="2006"/>
  </front>
  <seriesInfo name="ISO/IEC 22537:2006" value=""/>
</reference>
<reference anchor="SLICE" target="https://github.com/tc39/proposal-slice-notation">
  <front>
    <title>Slice notation</title>
    <author >
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="ECMA-262" target="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf">
  <front>
    <title>ECMAScript Language Specification, Standard ECMA-262, Third Edition</title>
    <author >
      <organization>Ecma International</organization>
    </author>
    <date year="1999" month="December"/>
  </front>
</reference>


    </references>


<section numbered="no" anchor="acknowledgements" title="Acknowledgements">

<t>This specification is based on <contact fullname="Stefan Gössner" />'s
original online article defining JSONPath <xref target="JSONPath-orig"/>.</t>

<t>The books example was taken from
http://coli.lili.uni-bielefeld.de/~andreas/Seminare/sommer02/books.xml
— a dead link now.</t>

<!--  LocalWords:  JSONPath XPath
 -->

</section>

    <section anchor="contributors" numbered="false" toc="include" removeInRFC="false">
        <name>Contributors</name>
    <contact initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization ascii="Universitaet Bremen TZI">Universität Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        <email>cabo@tzi.org</email>
      </address>
    </contact>
    </section>

  </back>

<!-- ##markdown-source:
H4sIAOIgzl8AA+1963LbSJbmfzxFDqs7LKlIiqQk22JZVSXrUlavb2PJWzXj
djRBMimiDQJsJGhZZXti3mH2/+6PjX2EfYDpN5kn2fOdkwkkQNBl99RMRUws
w2EKQF5Onvs5eRLsdDqBycNk+qcwThM9VHm20kG0zPgvkw96vcPeIJimkyRc
0ONpFs7yTpJmiyi5ztOk82eTJsswn3d6vWAS5kNl8mmQjk0a61ybobpzJ1gt
p6H7e5ImRidmhStMdScwq/EiMiZKk/x2STNcnF2dB3GYXA+VToJlNAyUytNJ
0Z6vpnqZz+nWPq7N7SLTM+O1MGmW125N0sVCJ7mxK8yjPKbJ/hC+DS8nWbTM
1bPxn/UkV0/TPMwJGLX1h8tnT7fVc1pbEI7HmX5LzemW3Mh0OFTHL66Cm+vy
tvrxh+DNjVwHWPNQDXqDXhCEq3yeZsOgo7IU0+pplKcZQRUlBNAPXZrVIZRu
CqZ/iG+T6v00o7n++5MbmrytLpJJFyuldeqcUUtrjPLbofoxSiZzbXKNCTJ9
TYtxz9OpLv5cJXlGrV/+N7pazpn2/EQvwigeqmuavlvS+ftr3O4SFjcs4qyr
LldZ+raA/2xKgE6Lmwz81VxfpqtYPV+N48jMaWj1OJ9uWMfjaBEa4qPPWcXJ
7ZK4tXkl2gCEbm6WlUUw1E+66kn0ZhVHk2hSQP4kzN6klfufifnnkQk/B9qL
q2ZIFws3pw9pAddlrmdhon746/81JmHqMlzn4WQ+TydzM5mvYq1OifcXq2Ra
QOXfYGBOO/v7/b1Dbw2XaZKQVOZZ+Nf/qdXhXR/YH3S2CJPbEkrDYHSvU81g
fD+bd6Z2iu5UBxDxPIvGq5w5voD+JMyoZ6Iephiv4OeXSfRWZybK//q/c/Uw
0ySk6uofL+RxaCZR5LUJda2NW8Dz1OQzwoPa2+vt7/eKtUtjb+WD+3sHh83L
swT5ev+wsz/odwb9+527e4eDfrnySThOv89/jroEWhBEyQxLyQk26KgX5yd7
BwcDwo+eQMsFX/G9+/3B3aGKwiTkm3zv7mGvP1TLNEpESBtuOZXSSbPoGsOT
2guza6x1nudLM9zddQToJjrfDbM8msTa7P6B9DE67kofq+acgvq3f/4X9RP/
RbCLnkIzp58UfzZxGz6/wHFKObXXu9fpDTqMPZ6Q9NLeSffF2UnnHczFoNcZ
9Pq9/qC/Ty3O9n8a+vB+a2e7cCgmfZzryTxJ4/T6llbxP9TZyZNjq7mxlJ+e
PFZbNMy2Mks9iWbRhHutra4jK7i4fMaXRmeRNqCkWzw92b04O1GDwcHevSGt
4251Wbi8fHxxcraBKFE+X40huLv5ZO9wd5mly9SEcceQXGsynHkJl13sJZ4o
7wmW1hncHazPQBPc3Nx09WQRdphTEu4TxuDI3SW0qqzb7M4icAMPdXnVOX5x
8mjXjdv+/aC3l03pf6hwao0bp3qiF2Od0Z/9w8PD7nI684H00P2YbPMqvNbq
0sd0mxiG3Aio/GIe0vcRrmWWTbQ4o9UQpb3VeBgHLJ3+IAiSuqzdHRzaPw8G
e/tDFY6TmVzfHxwcDhUckyDodDr0BJptkgdBIQdTPYsSbVQIDQIzZG6TPHzH
rBRNyU+IZre4/TaMV9oEN0TVKKHWv+wvkKe0gqPRlbmJrPpPQbCzQ6gwxUMV
YeqbNHtDZkgRj1xnJMuK8KfmoUEndUuqbqxJ0S3FVuppEKKFxRQ9PYUrtrOj
tm7mEWm+ROupId+IeqlZ9E5PyQtKk20fjhOnmWlpQVCFaBlN3hi1Wqp8rkkP
LVdxmJV6oyJUTJppUMo4A06reEuow8IKWgmemfqCWkLLRUJfRk1WWYZ5yfnM
yahGFieg1A0p5BIwM09vQIqbeZgXiwxokZOUjIIm7yE4sb4dw0G+JJGMdHUC
TEyjjKhEyKDOWJnIJ5lokkq4L7dqhxwBneUBbqk5jbijCNE3Oo7xvQWw0TGP
FppgIILgapFmhCU2HYBxntLDyBBUgHRKuJrq6babcxoZUnmT+feRzmeQVAVz
gpZEWMcoi2g6jcl6fgUCZ+l0NWGZ+TWp9P59xap8/Phb0w3goLtI41SNbwlG
K8AfP3Y9eY1EKKDzkimoiTmJYnE4gYHP24q4Wu4KadIbnc1WMTkji2WYsH4i
0eAJn4uRlalgd2kq9cdXwgY06IygS0gjU3sy5UyFG/AF4zzTsSjYebQU0HOi
Ja1GwbklYc2IsQiZ6Uy45ia1qoW0CHmPxAszHj/vFnDQKIxjcnVDSCawSV9k
WOPUktLpn6DQLsqhJVR/WWliY6vAcmAbvB/GhlXByhC6aCnEKrFarOI8Wnoj
m+7rgHjuK3Wl4emzeQXPafVG30JBEdVaT15eXrXa8q2ePuO/X5z9/cuLF2en
+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
9dOwVsY5XLuDezQesx3bU/l8sFbTZxe/3b1qu3ub2p1X251vaFfw/Aerrza0
u1uFr3d/U7u71XYbxzurtjve0O5ebd7TTe32q+0OG9t5+uOD1RvVdsTPrkSs
RucX5QsTTQtH8cxRa6ImrhDbT6v9LZGqZMPdyXFuwak4iRY3RWK/GMBaj1eO
j1TjsC9zdl0+/NN7VdVoshJMro9ga3Xm5cvJkMrA5mi7Vr0W4hCTjUbsFO1A
spI49ldv3gjSp5zyXQGtw5Mrd8VjW21cQC9NZIcAJ6+ucaQK2R/o835vuzKN
P+qRa453E0m/I/Wq1Wm9VlutHszGFluXvtrh7+3tT9qQb8pakE5lS6mn0obM
XqWnn7Jgk2MrTIm1KOpjRgUKAwsPTONev5YM/IYzi4zputUa+u9r4LdOMVey
5bFLtxP6s5VvZBr1+rJpMer0sKXgsQ4f8vTTBLKjUKCiGN4niSoj5DFeSRTz
uaY1MsngRBN7ruo1wvLWsIWvV9hiVq+b8Pqq0gynUqnn60DGKImO/uUVNysv
67jzVkvoGFpsDPEHDmCl7p0T1TqGtryVUVPLwXCA/ZPBkL+592C4Pxx1/zYL
/pV0sm8Uj6tv2f2cASrn0FhNeTvC/CbEypFlSXWFnHezRWh8SGzJb2rnl3o5
2fUVDZeWBqHqdeSMGo/X8HZO70DM6FXvdW0LmKtH/eEZWklL8zy8n3gtm9nu
RJ7IeHGgsFbO8UswdAY1IKQSflXReJWlyhafy9JgK83Tc8cF+1hkRt57BvN6
/phT4tylu8zSPMVmVJd5b6Tw9r506vY5vTPkxctqqpWsaOXeYK6Me6f5+/fu
3seP9qVqzOVTebd5AQSkYgQik81jL6wwa/UF2Be1ichW3ql5VXvNUAXPa6fH
Hc4Lu4U39ViScmPmuxyg0cWoTap7wr+KwA8IGIFZRMxWofD6RnQxcm8XxwK4
DkNZkZhuY0e+ktlv4Ir+EAcYtqRo3CLHbmvwztqoP9oO1lYgDq5dw8hp0sHI
JuHCXLJw21KMTn4uJjoYDpqw0TzWHtQIvyjQAgWBtgLR9lDpF8ZGSREe8/Rd
dTVfmXZQwcDo1cGwP+x8BigHBShtKadxy5Lbr4ZDPlfy6WR3YdGDKmhri+PN
6CRtXlp1y5u3sWF37DYLn3s2pWKoSJ5wsatNzMLIcAxjiztduTuGs4xdlqc4
XWqLbKwfVY4+W3HlgHt/pRTm8tZCEnhiTNNYUSq6FlHeV+rUvp/7SzeB1jw9
WoV9f2pYNeVp5tPB8/zKUkWOwzSOIPhE4+5SZlQX84LofMRcF6/C84lfVj7Y
knpbk2Vku5u4ILDbkTKdLamq8Em7glXxeaLrjdrsy514Z2zcGqM1VctvSOdn
xTSm7ZSViAL0kLyLGQ5rbisWaaA4D9sWyK6UthXvdC0Hw1anc666akTR8shx
uqvbWEOm5VWrqWwYBDn3BKpvK3sqjYxrVYW+VlXucGw1b1DW2XF4foJIy706
64N15fjFFsm0CAY3HdD0HiBkZC/t2yPVk7HcDtEHrL0MLLnVA/tUnnVUn/7q
FH96YeWpXXHlVXhyjl9MiMUFBOmyztoeYdbRFHKtYG5/tSGGO4TUBRAk04yR
LbEv7EahV3FOhj2xGK8Zlh/Twt/FTrJjudC4F8Gdv3x6gjfLF231VrSNnxO5
OFeR4Ovq0Zn8OM6Ls6uXL56qCL/M8vjyzL8H7HwtT56eUl+vnLmo0fREsHAO
KzYyej3ygZQ3xOfNQwTOI6qOMPSX8XV/2OeKsS/HvfuxAFIN8AwrOB8hPMts
j9VySX9bAWBieU5QIaLtQgFaYa8xPp/WwOGkYk/fjlCRXhFVTC6gMARib+xD
hkYerhH4IUO/xcttgznbzO1t0I4pnvzJxTklEvnONj+UoKd8RNfbgTBKKVsF
rwiYR+rJxdOtJ8c/bdnB26q3LTNyK4HXb8VweW0KRltvagfs9KU1fW+Ymces
NrNcGhQMvMXd2jLNtl+Nv8kkNXszY53faFtwJpBAXXt0MfwDItX61KXRq2mK
vKN4jqOQuHfEsTG/9b94dTlTOaiERGyxXPG606ve+zGdGucVFbRypCIERIQr
hhTv0n908fiM7jwQPMivE12ePT47uVKAia/RISJpx0gWldwvCEAsVOYVWtSf
g0cs5hDcPFDRF8/h65fSt6P2n3Ls3NEip0qsGjJSodRtOtImR2Tgx3luXLXq
cLNaCYpUyQw/DJM0nMG5Y8rXphTb7GUiqmsP46z49WfsAsrxyun6vFgHLA2n
Rbis1uReeIl3RQf8Nmd7liAQoNQXA9Vu6BI0IIqTlZywVBfHT49hyLkiyJ6w
eP8V7iKV8PB0SJ4pb/6HFKBO8X5QFL+6V9io9XfYBEh4TFYZ3iK/Nq57Uk9T
XGMbHlfSb1Lpx7kWvMzdRaVydPTgYCBHR/lnibCpxws6nqC4kjzpa1veUXGj
k7RMkVR+hIhuFC/becCFRCTXICuSwket2o/MtXa/vUPemn0RLg7sMIrkt+3K
d7oXxaxrv2hkHTc57F1U6cMPDt+QzHDlj/0htUkaR904ov9WSdQZRyQyMx3j
Jwx3/4nEBnHlLgUNBEimdw1+YSrrDfhMuum+W8QBfoQO5xdCFK0kb3Des2vP
U6vH6SSMf8Sv5wzLn/KzP4/AVRz/D9Djqyp3dQAA

-->

</rfc>

