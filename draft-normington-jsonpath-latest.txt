



Internet Engineering Task Force                       G. Normington, Ed.
Internet-Draft                                              VMware, Inc.
Intended status: Standards Track                           E. Surov, Ed.
Expires: 29 April 2021                           TheSoul Publishing Ltd.
                                                            M. Mikulicic
                                                            VMware, Inc.
                                                         26 October 2020


                 JavaScript Object Notation (JSON) Path
                    draft-normington-jsonpath-latest

Abstract

   JSON Path defines a string syntax for identifying values within a
   JavaScript Object Notation (JSON) document.

Note

   *This document is a work in progress and has not yet been published
   as an Internet Draft.*

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 29 April 2021.

Copyright Notice

   Copyright (c) 2020 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights



Normington, et al.        Expires 29 April 2021                 [Page 1]

Internet-Draft   JavaScript Object Notation (JSON) Path     October 2020


   and restrictions with respect to this document.  Code Components
   extracted from this document must include Simplified BSD License text
   as described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2
     1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   2
     1.2.  ABNF Syntax . . . . . . . . . . . . . . . . . . . . . . .   2
   2.  JSON Path Syntax and Semantics  . . . . . . . . . . . . . . .   3
     2.1.  Overview  . . . . . . . . . . . . . . . . . . . . . . . .   3
     2.2.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   3
     2.3.  Implementation  . . . . . . . . . . . . . . . . . . . . .   3
     2.4.  Syntax  . . . . . . . . . . . . . . . . . . . . . . . . .   4
     2.5.  Semantics . . . . . . . . . . . . . . . . . . . . . . . .   4
     2.6.  Selectors . . . . . . . . . . . . . . . . . . . . . . . .   5
       2.6.1.  Dot Child Selector  . . . . . . . . . . . . . . . . .   5
       2.6.2.  Union Selector  . . . . . . . . . . . . . . . . . . .   6
         2.6.2.1.  Syntax  . . . . . . . . . . . . . . . . . . . . .   6
         2.6.2.2.  Semantics . . . . . . . . . . . . . . . . . . . .   7
         2.6.2.3.  Union Child . . . . . . . . . . . . . . . . . . .   7
         2.6.2.4.  Array Access  . . . . . . . . . . . . . . . . . .   9
   3.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  12
   4.  Security Considerations . . . . . . . . . . . . . . . . . . .  12
   5.  Alternatives  . . . . . . . . . . . . . . . . . . . . . . . .  12
   6.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  13
     6.1.  Normative References  . . . . . . . . . . . . . . . . . .  13
     6.2.  Informative References  . . . . . . . . . . . . . . . . .  13
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  14

1.  Introduction

   JSON Path, or rather JSONPath, was introduced by Stefan Goessner as a
   simple form of XPath for JSON.  See his original article [Goessner].

   JSON is defined by RFC 8259 [RFC8259].

1.1.  Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

1.2.  ABNF Syntax

   The syntax in this document conforms to ABNF as defined by RFC 5234
   [RFC5234].



Normington, et al.        Expires 29 April 2021                 [Page 2]

Internet-Draft   JavaScript Object Notation (JSON) Path     October 2020


   ABNF terminal values in this document define Unicode code points
   rather than their UTF-8 encoding.  For example, the Unicode PLACE OF
   INTEREST SIGN (U+2318) would be defined in ABNF as "%x2318".

2.  JSON Path Syntax and Semantics

2.1.  Overview

   A JSON Path is a string which selects zero or more nodes of any JSON
   document.  A valid JSON Path conforms to the ABNF syntax defined by
   this document.

   A JSON Path MUST be encoded using UTF-8.  To parse a JSON Path
   according to the grammar in this document, its UTF-8 form SHOULD
   first be decoded into Unicode code points as described in RFC 3629
   [RFC3629].

2.2.  Terminology

   A JSON document is logically a tree of nodes with the document as the
   root node of the tree.

   Each node holds a JSON value (as defined by RFC 8259 [RFC8259]) of
   one of the types object, array, number, string, or one of the
   literals "true", "false", or "null".  The type of the JSON value held
   by a node is sometimes referred to as the type of the node.

2.3.  Implementation

   An implementation of this specification, from now on referred to
   simply as "an implementation", SHOULD takes two inputs, a JSON Path
   and a JSON document, and produce a possibly empty list of nodes of
   the JSON document which are selected by the JSON Path or an error
   (but not both).

   If no node is selected and no error has occurred, an implementation
   MUST return an empty list of nodes.

   Syntax errors in the JSON Path SHOULD be detected before selection is
   attempted since these errors do not depend on the JSON document.
   Therefore, an implementation SHOULD take a JSON Path and produce an
   optional syntax error and then, if and only if an error was not
   produced, SHOULD take a JSON document and produce a list of nodes or
   an error (but not both).

   Alternatively, an implementation MAY take a JSON Path and a JSON
   document and produce a list of nodes or an optional error (but not
   both).



Normington, et al.        Expires 29 April 2021                 [Page 3]

Internet-Draft   JavaScript Object Notation (JSON) Path     October 2020


   For any implementation, if a syntactically invalid JSON Path is
   provided, the implementation MUST return an error.

   If a syntactially invalid JSON document is provided, any
   implementation SHOULD return an error.

2.4.  Syntax

   Syntactically, a JSON Path consists of a root selector ("$"), which
   selects the root node of a JSON document, followed by a possibly
   empty sequence of _selectors_.

   json-path = root-selector *selector
   root-selector = %x24               ; $ selects document root node

   The syntax and semantics of each selector is defined below.

2.5.  Semantics

   The root selector "$" not only selects the root node of the input
   document, but it also produces as output a list consisting of one
   node: the input document.

   A selector may select zero or more nodes for further processing.  A
   syntactically valid selector MUST NOT produce errors.  This means
   that some operations which might be considered erroneous, such as
   indexing beyond the end of an array, simply result in fewer nodes
   being selected.

   But a selector doesn't just act on a single node: each selector acts
   on a list of nodes and produces a list of nodes, as follows.

   After the root selector, the remainder of the JSON Path is processed
   by passing lists of nodes from one selector to the next ending up
   with a list of nodes which is the result of applying the JSON Path to
   the input JSON document.

   Each selector acts on its input list of nodes as follows.  For each
   node in the list, the selector selects zero or more nodes, each of
   which is a descendant of the node or the node itself.  The output
   list of nodes of a selector is the concatenation of the lists of
   selected nodes for each input node.

   A specific, non-normative example will make this clearer.  Suppose
   the input document is: "{"a":[{"b":0},{"b":1},{"c":2}]}".  As we will
   see later, the JSON Path "$.a[*].b" selects the following list of
   nodes: "0", "1".  Let's walk through this in detail.




Normington, et al.        Expires 29 April 2021                 [Page 4]

Internet-Draft   JavaScript Object Notation (JSON) Path     October 2020


   The JSON Path consists of "$" followed by three selectors: ".a",
   "[*]", and ".b".

   Firstly, "$" selects the root node which is the input document.  So
   the result is a list consisting of just the root node.

   Next, ".a" selects from any input node of type object and selects any
   value of the input node corresponding to the key ""a"".  The result
   is again a list of one node: "[{"b":0},{"b":1},{"c":2}]".

   Next, "[*]" selects from any input node which is an array and selects
   all the elements of the input node.  The result is a list of three
   nodes: "{"b":0}", "{"b":1}", and "{"c":2}".

   Finally, ".b" selects from any input node of type object with a key
   "b" and selects the value of the input node corresponding to that
   key.  The result is a list containing "0", "1".  This is the
   concatenation of three lists, two of length one containing "0", "1",
   respectively, and one of length zero.

   As a consequence of this approach, if any of the selectors selects no
   nodes, then the whole JSON Path selects no nodes.

   In what follows, the semantics of each selector are defined for each
   type of node.

2.6.  Selectors

2.6.1.  Dot Child Selector

Syntax

   A dot child selector has a key known as a dot child name or a single
   asterisk ("*").

   A dot child name corresponds to a name in a JSON object.















Normington, et al.        Expires 29 April 2021                 [Page 5]

Internet-Draft   JavaScript Object Notation (JSON) Path     October 2020


   selector = dot-child               ; see below for alternatives
   dot-child = %x2E dot-child-name / ; .<dot-child-name>
               %x2E %x2A             ; .*
   dot-child-name = 1*(
                      %x2D /         ; -
                      DIGIT /
                      ALPHA /
                      %x5F /         ; _
                      %x80-10FFFF    ; any non-ASCII Unicode character
                    )
   DIGIT =  %x30-39                  ; 0-9
   ALPHA = %x41-5A / %x61-7A         ; A-Z / a-z

   More general child names, such as the empty string, are supported by
   "Union Child" (Section 2.6.2.3).

   Note that the "dot-child-name" rule follows the philosophy of JSON
   strings and is allowed to contain bit sequences that cannot encode
   Unicode characters (a single unpaired UTF-16 surrogate, for example).
   The behaviour of an implementation is undefined for child names which
   do not encode Unicode characters.

Semantics

   A dot child name which is not a single asterisk ("*") is considered
   to have a key.  It selects the value corresponding to the key from
   any object node.  It selects no nodes from a node which is not an
   object.

   The key of a dot child name is the sequence of Unicode characters
   contained in that name.

   A dot child name consisting of a single asterisk is a wild card.  It
   selects all the values of any object node.  It also selects all the
   elements of any array node.  It selects no nodes from number, string,
   or literal nodes.

2.6.2.  Union Selector

2.6.2.1.  Syntax

   A union selector consists of one or more union elements.









Normington, et al.        Expires 29 April 2021                 [Page 6]

Internet-Draft   JavaScript Object Notation (JSON) Path     October 2020


   selector =/ union
   union = %x5B ws union-elements ws %x5D ; [...]
   ws = *%x20                             ; zero or more spaces
   union-elements = union-element /
                    union-element ws %x2C ws union-elements
                                          ; ,-separated list

2.6.2.2.  Semantics

   A union selects any node which is selected by at least one of the
   union selectors and selects the concatenation of the lists (in the
   order of the selectors) of nodes selected by the union elements.

2.6.2.3.  Union Child

Syntax

   A union child is a union element consisting of a quoted string.

































Normington, et al.        Expires 29 April 2021                 [Page 7]

Internet-Draft   JavaScript Object Notation (JSON) Path     October 2020


   union-element = union-child ; see below for more alternatives
   union-child = %x22 *double-quoted %x22 / ; "string"
                 %x27 *single-quoted %x27   ; 'string'

   double-quoted = dq-unescaped /
             escape (
                 %x22 /          ; "    quotation mark  U+0022
                 %x2F /          ; /    solidus         U+002F
                 %x5C /          ; \    reverse solidus U+005C
                 %x62 /          ; b    backspace       U+0008
                 %x66 /          ; f    form feed       U+000C
                 %x6E /          ; n    line feed       U+000A
                 %x72 /          ; r    carriage return U+000D
                 %x74 /          ; t    tab             U+0009
                 %x75 4HEXDIG )  ; uXXXX                U+XXXX


         dq-unescaped = %x20-21 / %x23-5B / %x5D-10FFFF

   single-quoted = sq-unescaped /
             escape (
                 %x27 /          ; '    apostrophe      U+0027
                 %x2F /          ; /    solidus         U+002F
                 %x5C /          ; \    reverse solidus U+005C
                 %x62 /          ; b    backspace       U+0008
                 %x66 /          ; f    form feed       U+000C
                 %x6E /          ; n    line feed       U+000A
                 %x72 /          ; r    carriage return U+000D
                 %x74 /          ; t    tab             U+0009
                 %x75 4HEXDIG )  ; uXXXX                U+XXXX

         sq-unescaped = %x20-26 / %x28-5B / %x5D-10FFFF

   escape = %x5C                 ; \

   HEXDIG =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"

   Note: double-quoted strings follow JSON in RFC 8259 [RFC8259].
   Single-quoted strings follow an analogous pattern.

Semantics

   If the union child is a quoted string, the string MUST be converted
   to a key by removing the surrounding quotes and replacing each escape
   sequence with its equivalent Unicode character, as in the table
   below:





Normington, et al.        Expires 29 April 2021                 [Page 8]

Internet-Draft   JavaScript Object Notation (JSON) Path     October 2020


                  +=================+===================+
                  | Escape Sequence | Unicode Character |
                  +=================+===================+
                  |    %x5C %x22    |       U+0022      |
                  +-----------------+-------------------+
                  |    %x5C %x27    |       U+0027      |
                  +-----------------+-------------------+
                  |    %x5C %x2F    |       U+002F      |
                  +-----------------+-------------------+
                  |    %x5C %x5C    |       U+005C      |
                  +-----------------+-------------------+
                  |    %x5C %x62    |       U+0008      |
                  +-----------------+-------------------+
                  |    %x5C %x66    |       U+000C      |
                  +-----------------+-------------------+
                  |    %x5C %x6E    |       U+000A      |
                  +-----------------+-------------------+
                  |    %x5C %x72    |       U+000D      |
                  +-----------------+-------------------+
                  |    %x5C %x74    |       U+0009      |
                  +-----------------+-------------------+
                  |    %x5C uXXXX   |       U+XXXX      |
                  +-----------------+-------------------+

                   Table 1: Escape Sequence Replacements

   The union child selects the value corresponding to the key from any
   object node with the key as a name.  It selects no nodes from a node
   which is not an object.

2.6.2.4.  Array Access

Syntax

   Array access is a union element which selects zero or more elements
   of an array node.  Array access takes the form of an index, which
   selects at most one element, or a slice, which selects zero or more
   elements.

   union-element =/ array-index / array-slice

   An array index is a union element consisting of an integer (in base
   10).








Normington, et al.        Expires 29 April 2021                 [Page 9]

Internet-Draft   JavaScript Object Notation (JSON) Path     October 2020


   array-index = integer

   integer = [%x2D] (%x30 / (%x31-39 *%x30-39))
                               ; optional - followed by 0 or
                               ; sequence of digits with no leading zero

   Note: the syntax does not allow integers with leading zeros such as
   "01" and "-01".

   An array slice is a union element consisting of two or three integers
   (in base 10 and which may be omitted) separated by colons.

   array-slice = [ integer ] ws %x3A ws [ integer ]
                      [ ws %x3A ws [ integer ] ]
                               ; start:end or start:end:step

Semantics

   Array slicing is inspired by the behaviour of the
   "Array.prototype.slice" method of the JavaScript language as defined
   by the ECMA-262 standard [ECMA-262], with the addition of the "step"
   parameter, which is inspired by the Python slice expression.  This
   section specifies the behaviour fully, without depending on
   JavaScript or Python behaviour.  Array indexing is defined in terms
   of array slicing.

   A slice expression selects a subset of the elements of the input
   array, in the same order as the array or the reverse order, depending
   on the sign of the "step" parameter.  It selects no nodes from a node
   which is not an array.

   A slice is defined by the two slice parameters, "start" and "end",
   and an iteration delta, "step".  Each of these parameters is
   optional.  "len" is the length of the input array.

   The default value for "step" is "1".  The default values for "start"
   and "end" depend on the sign of "step", as follows:

                    +===========+=========+==========+
                    | Condition | start   | end      |
                    +===========+=========+==========+
                    | step >= 0 | 0       | len      |
                    +-----------+---------+----------+
                    | step < 0  | len - 1 | -len - 1 |
                    +-----------+---------+----------+

                       Table 2: Default array slice
                           start and end values



Normington, et al.        Expires 29 April 2021                [Page 10]

Internet-Draft   JavaScript Object Notation (JSON) Path     October 2020


   Slice expression parameters "start" and "end" are not directly usable
   as slice bounds and must first be normalized.  Normalization is
   defined as:

   FUNCTION Normalize(i):
     IF i >= 0 THEN
       RETURN i
     ELSE
       RETURN len + i
     END IF

   The result of the array indexing expression "[i]" is defined to be
   the result of the array slicing expression "[i:Normalize(i)+1:1]".

   Slice expression parameters "start" and "end" are used to derive
   slice bounds "lower" and "upper".  The direction of the iteration,
   defined by the sign of "step", determines which of the parameters is
   the lower bound and which is the upper bound:

   FUNCTION Bounds(start, end, step, len):
     n_start = Normalize(start)
     n_end = Normalize(end)

     IF step >= 0 THEN
       lower = MIN(MAX(n_start, 0), len)
       upper = MIN(MAX(n_end, 0), len)
     ELSE
       upper = MIN(MAX(n_start, -1), len-1)
       lower = MIN(MAX(n_end, -1), len-1)
     END IF

     RETURN (lower, upper)

   The slice expression selects elements with indices between the lower
   and upper bounds.  In the following pseudocode, the "a(i)" construct
   expresses the 0-based indexing operation on the underlying array.















Normington, et al.        Expires 29 April 2021                [Page 11]

Internet-Draft   JavaScript Object Notation (JSON) Path     October 2020


   IF step > 0 THEN

     i = lower
     WHILE i < upper:
       SELECT a(i)
       i = i + step
     END WHILE

   ELSE if step < 0 THEN

     i = upper
     WHILE lower < i:
       SELECT a(i)
       i = i + step
     END WHILE

   END IF

   When "step = 0", no elements are selected and the result array is
   empty.

   An implementation MUST raise an error if any of the slice expression
   parameters does not fit in the implementation's representation of an
   integer.  If a successfully parsed slice expression is evaluated
   against an array whose size doesn't fit in the implementation's
   representation of an integer, the implementation MUST raise an error.

3.  IANA Considerations

   This memo includes no request to IANA.

   All drafts are required to have an IANA considerations section (see
   Guidelines for Writing an IANA Considerations Section in RFCs
   [RFC5226] for a guide).  If the draft does not require IANA to do
   anything, the section contains an explicit statement that this is the
   case (as above).  If there are no requirements for IANA, the section
   will be removed during conversion into an RFC by the RFC Editor.

4.  Security Considerations

   This section gives security considerations, as required by RFC 3552
   [RFC3552].

5.  Alternatives

   An analogous standard, JSON Pointer, is provided by RFC 6901
   [RFC6901].




Normington, et al.        Expires 29 April 2021                [Page 12]

Internet-Draft   JavaScript Object Notation (JSON) Path     October 2020


6.  References

6.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC3629]  Yergeau, F., "UTF-8, a transformation format of ISO
              10646", STD 63, RFC 3629, DOI 10.17487/RFC3629, November
              2003, <https://www.rfc-editor.org/info/rfc3629>.

   [RFC5234]  Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, RFC 5234,
              DOI 10.17487/RFC5234, January 2008,
              <https://www.rfc-editor.org/info/rfc5234>.

6.2.  Informative References

   [ECMA-262] Ecma International, "ECMAScript Language Specification,
              Standard ECMA-262, Third Edition", December 1999,
              <http://www.ecma-international.org/publications/files/
              ECMA-ST-ARCH/ECMA-
              262,%203rd%20edition,%20December%201999.pdf>.

   [Goessner] Stefan Gössner, "JSONPath - XPath for JSON", February
              2007, <https://goessner.net/articles/JsonPath/>.

   [RFC3552]  Rescorla, E. and B. Korver, "Guidelines for Writing RFC
              Text on Security Considerations", BCP 72, RFC 3552,
              DOI 10.17487/RFC3552, July 2003,
              <https://www.rfc-editor.org/info/rfc3552>.

   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", RFC 5226,
              DOI 10.17487/RFC5226, May 2008,
              <https://www.rfc-editor.org/info/rfc5226>.

   [RFC6901]  Bryan, P., Ed., Zyp, K., and M. Nottingham, Ed.,
              "JavaScript Object Notation (JSON) Pointer", RFC 6901,
              DOI 10.17487/RFC6901, April 2013,
              <https://www.rfc-editor.org/info/rfc6901>.

   [RFC8259]  Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", STD 90, RFC 8259,
              DOI 10.17487/RFC8259, December 2017,
              <https://www.rfc-editor.org/info/rfc8259>.



Normington, et al.        Expires 29 April 2021                [Page 13]

Internet-Draft   JavaScript Object Notation (JSON) Path     October 2020


Authors' Addresses

   Glyn Normington (editor)
   VMware, Inc.
   Winchester
   United Kingdom

   Email: glyn.normington@gmail.com


   Edward Surov (editor)
   TheSoul Publishing Ltd.
   Limassol
   Cyprus

   Email: esurov.tsp@gmail.com


   Marko Mikulicic
   VMware, Inc.
   Pisa
   Italy

   Email: mmikulicic@gmail.com



























Normington, et al.        Expires 29 April 2021                [Page 14]
