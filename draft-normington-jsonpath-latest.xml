<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<rfc
      xmlns:xi="http://www.w3.org/2001/XInclude"
      category="std"
      consensus="true"
      docName="draft-normington-jsonpath-latest"
      ipr="trust200902"
      obsoletes=""
      updates=""
      submissionType="IETF"
      xml:lang="en"
      tocInclude="true"
      tocDepth="4"
      symRefs="true"
      sortRefs="true"
      version="3">
  <!-- xml2rfc v2v3 conversion 2.38.1 -->
  <!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902
    you can add the attributes updates="NNNN" and obsoletes="NNNN"
    they will automatically be output with "(if approved)" -->

 <!-- ***** FRONT MATTER ***** -->

 <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
        full title is longer than 39 characters -->

   <title>JavaScript Object Notation (JSON) Path</title>
    <seriesInfo name="Internet-Draft" value="draft-normington-jsonpath-00"/>
    <!-- add 'role="editor"' below for the editors if appropriate -->

   <!-- Another author who claims to be an editor -->

    <author fullname="Glyn Normington" initials="G" role="editor" surname="Normington">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street/>
          <city>Winchester</city>
          <region/>
          <code/>
          <country>UK</country>
        </postal>
        <phone/>
        <email>glyn.normington@gmail.com</email>
     </address>
    </author>
    <author fullname="Edward Surov" initials="E" role="editor" surname="Surov">
      <organization>TheSoul Publishing Ltd.</organization>
      <address>
        <postal>
          <street/>
          <city>Limassol</city>
          <region/>
          <code/>
          <country>Cyprus</country>
        </postal>
        <phone/>
        <email>esurov.tsp@gmail.com</email>
     </address>
    </author>
    <author fullname="Marko Mikulicic" initials="M" surname="Mikulicic">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street/>
          <city>Pisa</city>
          <region/>
          <code/>
          <country>IT</country>
        </postal>
        <phone/>
        <email>mmikulicic@gmail.com</email>
     </address>
    </author>
    <date year="2020"/>
    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
        in the current day for you. If only the current year is specified, xml2rfc will fill
	 in the current day and month for you. If the year is not the current one, it is
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to
	 specify just the year. -->

   <!-- Meta-data Declarations -->

   <area>General</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <!-- WG name at the upperleft corner of the doc,
        IETF is fine for individual submissions.
	 If this element is not present, the default is "Network Working Group",
        which is used by the RFC Editor as a nod to the history of the IETF. -->

   <keyword>JSON</keyword>
   <keyword>JSONPath</keyword>
    <!-- Keywords will be incorporated into HTML output
        files in a meta tag but they have no effect on text or nroff
        output. If you submit your draft to the RFC Editor, the
        keywords will be used for the search engine. -->

   <abstract>
      <t>JSON Path defines a string syntax for identifying values
   within a JavaScript Object Notation (JSON) document.</t>
    </abstract>
    <note>
      <t><strong>This document is a work in progress and has not yet been published as an Internet Draft.</strong></t>
    </note>
  </front>

   <!-- ***** MIDDLE MATTER ***** -->

  <middle>
    <section numbered="true" toc="default">
      <name>Introduction</name>
      <!-- move the following to an Acknowledgements appendix and write a proper introduction -->
      <t>JSON Path, or rather JSONPath, was introduced by Stefan Goessner as a simple form of XPath for JSON.
         See his original article <xref target="Goessner" format="default">Goessner</xref>.
      </t>
      <t>JSON is defined by <xref target="RFC8259" format="default">RFC&nbsp;8259</xref>.
      </t>

      <section numbered="true" toc="default">
        <name>Requirements Language</name>
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
       "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
       document are to be interpreted as described in <xref target="RFC2119" format="default">RFC&nbsp;2119</xref>.</t>
      </section>

      <section numbered="true" toc="default">
        <name>ABNF Syntax</name>
        <t>The syntax in this document conforms to ABNF as defined by <xref target="RFC5234" format="default">RFC&nbsp;5234</xref>.
        </t>
        <t>ABNF terminal values in this document define Unicode code points rather than their UTF-8 encoding.
           For example, the Unicode PLACE OF INTEREST SIGN (U+2318) would be defined in ABNF as <tt>%x2318</tt>.
        </t>
      </section>
    </section>
   <section numbered="true" toc="default">
      <name>JSON Path Syntax and Semantics</name>
         <section numbered="true" toc="default">
            <name>Overview</name>
            <t>A JSON Path is a string which selects zero or more nodes of any JSON document. A valid JSON Path conforms to the ABNF syntax defined by this document.
            </t>
            <t>A JSON Path MUST be encoded using UTF-8. To parse a JSON Path according to the grammar in this document, its UTF-8 form SHOULD first be decoded into Unicode code points as described
               in <xref target="RFC3629" format="default">RFC&nbsp;3629</xref>.
            </t>
         </section>
         <section numbered="true" toc="default">
            <name>Terminology</name>
            <t>A JSON document is logically a tree of nodes with the document as the root node of the tree.
            </t>
            <t>Each node holds a JSON value (as defined by <xref target="RFC8259" format="default">RFC&nbsp;8259</xref>) of one of the types object, array, number, string, or one
               of the literals <tt>true</tt>, <tt>false</tt>, or <tt>null</tt>. The type of the JSON value held by a node is sometimes referred to as the type of the node.
            </t>
         </section>
         <section numbered="true" toc="default">
            <name>Implementation</name>
            <t>An implementation of this specification, from now on referred to simply as "an implementation", SHOULD takes two inputs, a JSON Path and a JSON document, and produce
               a possibly empty list of nodes of the JSON document which are selected by the JSON Path or an error (but not both).
            </t>
            <t>If no node is selected and no error has occurred, an implementation MUST return an empty list of nodes.
            </t>
            <t>Syntax errors in the JSON Path SHOULD be detected before selection is attempted since these errors do not depend on the JSON document.
               Therefore, an implementation SHOULD take a JSON Path and produce an optional syntax error and then,
               if and only if an error was not produced, SHOULD take a JSON document and produce a list of nodes or an error (but not both).
            </t>
            <t>Alternatively, an implementation MAY take a JSON Path and a JSON document and produce a list of nodes or an optional error (but not both).
            </t>
            <t>For any implementation, if a syntactically invalid JSON Path is provided, the implementation MUST return an error.
            </t>
            <t>If a syntactially invalid JSON document is provided, any implementation SHOULD return an error.
            </t>
         </section>
         <section numbered="true" toc="default">
            <name>Syntax</name>
            <t>Syntactically, a JSON Path consists of a root selector (<tt>$</tt>), which selects the root node of a JSON document, followed by a possibly empty sequence of <em>selectors</em>.
            </t>
            <sourcecode type="abnf">
json-path = root-selector *selector
root-selector = %x24               ; $ selects document root node
            </sourcecode>
            <t>The syntax and semantics of each selector is defined below.
            </t>
         </section>
         <section numbered="true" toc="default">
            <name>Semantics</name>
            <t>The root selector <tt>$</tt> not only selects the root node of the input document, but it also produces as output a list consisting of one node: the input document.
            </t>
            <t>A selector may select zero or more nodes for further processing.
               A syntactically valid selector MUST NOT produce errors. This means that some operations which might be considered erroneous, such as indexing beyond the end of an array,
               simply result in fewer nodes being selected.
            </t>
            <t>But a selector doesn't just act on a single node: each selector acts on a list of nodes and produces a list of nodes, as follows.
            </t>
            <t>After the root selector, the remainder of the JSON Path is processed by passing lists of nodes from one selector to the next ending up with a list of nodes which is the result of
               applying the JSON Path to the input JSON document.
            </t>
            <t>Each selector acts on its input list of nodes as follows. For each node in the list, the selector selects zero or more nodes, each of which is a descendant of the node or the node itself.
               The output list of nodes of a selector is the concatenation of the lists of selected nodes for each input node.
            </t>
            <t>A specific, non-normative example will make this clearer. Suppose the input document is: <tt>{"a":[{"b":0},{"b":1},{"c":2}]}</tt>. As we will see later, the JSON Path
               <tt>$.a[*].b</tt> selects the following list of nodes: <tt>0</tt>, <tt>1</tt>. Let's walk through this in detail.
            </t>
            <t>The JSON Path consists of <tt>$</tt> followed by three selectors: <tt>.a</tt>, <tt>[*]</tt>, and <tt>.b</tt>.
            </t>
            <t>Firstly, <tt>$</tt> selects the root node which is the input document. So the result is a list consisting of just the root node.
            </t>
            <t>Next, <tt>.a</tt> selects from any input node of type object and selects any value of the input node corresponding to the key <tt>"a"</tt>.
               The result is again a list of one node: <tt>[{"b":0},{"b":1},{"c":2}]</tt>.
            </t>
            <t>Next, <tt>[*]</tt> selects from any input node which is an array and selects all the elements of the input node.
               The result is a list of three nodes: <tt>{"b":0}</tt>, <tt>{"b":1}</tt>, and <tt>{"c":2}</tt>.
            </t>
            <t>Finally, <tt>.b</tt> selects from any input node of type object with a key <tt>b</tt> and selects the value of the input node corresponding to that key.
               The result is a list containing <tt>0</tt>, <tt>1</tt>.
               This is the concatenation of three lists, two of length one containing <tt>0</tt>, <tt>1</tt>, respectively, and one of length zero.
            </t>
            <t>As a consequence of this approach, if any of the selectors selects no nodes, then the whole JSON Path selects no nodes.
            </t>
            <t>In what follows, the semantics of each selector are defined for each type of node.
            </t>
         </section>
         <section numbered="true" toc="default">
            <name>Selectors</name>
            <section numbered="true" toc="default">
               <name>Dot Child Selector</name>
               <section numbered="false" toc="exclude">
                  <name>Syntax</name>
                  <t>A dot child selector has a key known as a dot child name or a single asterisk (<tt>*</tt>).
                  </t>
                  <t>A dot child name corresponds to a name in a JSON object.
                  </t>
                  <sourcecode type="abnf">
selector = dot-child               ; see below for alternatives
dot-child = %x2E dot-child-name / ; .&lt;dot-child-name&gt;
            %x2E %x2A             ; .*
dot-child-name = 1*(
                   %x2D /         ; -
                   DIGIT /
                   ALPHA /
                   %x5F /         ; _
                   %x80-10FFFF    ; any non-ASCII Unicode character
                 )
DIGIT =  %x30-39                  ; 0-9
ALPHA = %x41-5A / %x61-7A         ; A-Z / a-z
                  </sourcecode>
                  <t>More general child names, such as the empty string, are supported by "Union Child" (<xref target="unionchild" format="default"/>).
                  </t>
                  <t>Note that the <tt>dot-child-name</tt> rule follows the philosophy of JSON strings and is
                     allowed to contain bit sequences that cannot encode Unicode characters (a single unpaired UTF-16 surrogate, for example).
                     The behaviour of an implementation is undefined for child names which do not encode Unicode characters.
                  </t>
               </section>
               <section numbered="false" toc="exclude">
                  <name>Semantics</name>
                  <t>A dot child name which is not a single asterisk (<tt>*</tt>) is considered to have a key.
                      It selects the value corresponding to the key from any object node. It selects no nodes from a node which is not an object.
                  </t>
                   <t>The key of a dot child name is the sequence of Unicode characters contained in that name.
                   </t>
                  <t>A dot child name consisting of a single asterisk is a wild card. It selects all the values of any object node.
                     It also selects all the elements of any array node. It selects no nodes from number, string, or literal nodes.
                  </t>
               </section>
            </section>
            <section numbered="true" toc="default">
               <name>Union Selector</name>
               <section numbered="true" toc="default">
                  <name>Syntax</name>
                  <t>A union selector consists of one or more union elements.
                  </t>
                  <sourcecode type="abnf">
selector =/ union
union = %x5B ws union-elements ws %x5D ; [...]
ws = *%x20                             ; zero or more spaces
union-elements = union-element /
                 union-element ws %x2C ws union-elements
                                       ; ,-separated list
                  </sourcecode>
               </section>
               <section numbered="true" toc="default">
                  <name>Semantics</name>
                  <t>A union selects any node which is selected by at least one of the union selectors and selects the concatenation of the
                     lists (in the order of the selectors) of nodes selected by the union elements.
                     <!-- TODO: define whether duplicates are kept or removed. -->
                  </t>
               </section>
               <section numbered="true" toc="default" anchor="unionchild">
                  <name>Union Child</name>
                  <section numbered="false" toc="exclude">
                     <name>Syntax</name>
                     <t>A union child is a union element consisting of a quoted string.
                     </t>
                     <sourcecode type="abnf">
union-element = union-child ; see below for more alternatives
union-child = %x22 *double-quoted %x22 / ; "string"
              %x27 *single-quoted %x27   ; 'string'

double-quoted = dq-unescaped /
          escape (
              %x22 /          ; "    quotation mark  U+0022
              %x2F /          ; /    solidus         U+002F
              %x5C /          ; \    reverse solidus U+005C
              %x62 /          ; b    backspace       U+0008
              %x66 /          ; f    form feed       U+000C
              %x6E /          ; n    line feed       U+000A
              %x72 /          ; r    carriage return U+000D
              %x74 /          ; t    tab             U+0009
              %x75 4HEXDIG )  ; uXXXX                U+XXXX


      dq-unescaped = %x20-21 / %x23-5B / %x5D-10FFFF

single-quoted = sq-unescaped /
          escape (
              %x27 /          ; '    apostrophe      U+0027
              %x2F /          ; /    solidus         U+002F
              %x5C /          ; \    reverse solidus U+005C
              %x62 /          ; b    backspace       U+0008
              %x66 /          ; f    form feed       U+000C
              %x6E /          ; n    line feed       U+000A
              %x72 /          ; r    carriage return U+000D
              %x74 /          ; t    tab             U+0009
              %x75 4HEXDIG )  ; uXXXX                U+XXXX

      sq-unescaped = %x20-26 / %x28-5B / %x5D-10FFFF

escape = %x5C                 ; \

HEXDIG =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
                     </sourcecode>
                     <t>Note: double-quoted strings follow JSON in <xref target="RFC8259" format="default">RFC&nbsp;8259</xref>.
                        Single-quoted strings follow an analogous pattern.
                     </t>
                  </section>
                  <section numbered="false" toc="exclude">
                     <name>Semantics</name>
                     <t>If the union child is a quoted string, the string MUST be converted to a key by removing the surrounding quotes and
                        replacing each escape sequence with its equivalent Unicode character, as in the table below:
                     </t>
                     <table>
                        <name>Escape Sequence Replacements</name>
                        <thead>
                           <tr><th align='center'>Escape Sequence</th> <th align='center'>Unicode Character</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>   <td align='center'>%x5C %x22</td>         <td align='center'>U+0022</td></tr>
                           <tr>   <td align='center'>%x5C %x27</td>         <td align='center'>U+0027</td></tr>
                           <tr>   <td align='center'>%x5C %x2F</td>         <td align='center'>U+002F</td></tr>
                           <tr>   <td align='center'>%x5C %x5C</td>         <td align='center'>U+005C</td></tr>
                           <tr>   <td align='center'>%x5C %x62</td>         <td align='center'>U+0008</td></tr>
                           <tr>   <td align='center'>%x5C %x66</td>         <td align='center'>U+000C</td></tr>
                           <tr>   <td align='center'>%x5C %x6E</td>         <td align='center'>U+000A</td></tr>
                           <tr>   <td align='center'>%x5C %x72</td>         <td align='center'>U+000D</td></tr>
                           <tr>   <td align='center'>%x5C %x74</td>         <td align='center'>U+0009</td></tr>
                           <tr>   <td align='center'>%x5C uXXXX</td>        <td align='center'>U+XXXX</td></tr>
                        </tbody>
                     </table>
                     <t>
                        The union child selects the value corresponding to the key from any object node with the key as a name.
                        It selects no nodes from a node which is not an object.
                     </t>
                  </section>
               </section>
               <section numbered="true" toc="default">
                  <name>Array Access</name>
                  <section numbered="false" toc="exclude">
                     <name>Syntax</name>
                     <t>Array access is a union element which selects zero or more elements of an array node.
                        Array access takes the form of an index, which selects at most one element, or a slice, which selects zero or more elements.
                     </t>
                     <sourcecode type="abnf">
union-element =/ array-index / array-slice
                     </sourcecode>
                     <t>An array index is a union element consisting of an integer (in base 10).
                     </t>
                     <sourcecode type="abnf">
array-index = integer

integer = [%x2D] (%x30 / (%x31-39 *%x30-39))
                            ; optional - followed by 0 or
                            ; sequence of digits with no leading zero
                     </sourcecode>
                     <t>Note: the syntax does not allow integers with leading zeros such as <tt>01</tt> and <tt>-01</tt>.
                     </t>
                     <t>An array slice is a union element consisting of two or three integers (in base 10 and which may be omitted) separated by colons.
                     </t>
                     <sourcecode type="abnf">
array-slice = [ integer ] ws %x3A ws [ integer ]
                   [ ws %x3A ws [ integer ] ]
                            ; start:end or start:end:step
                    </sourcecode>
                  </section>
                  <section numbered="false" toc="exclude">
                     <name>Semantics</name>
                     <t>Array slicing is inspired by the behaviour of the <tt>Array.prototype.slice</tt> method
                        of the JavaScript language as defined by the ECMA-262 standard
                        <xref target="ECMA-262" format="default">ECMA-262</xref>,
                        with the addition of the <tt>step</tt> parameter, which is inspired by the Python slice expression.
                        This section specifies the behaviour fully, without depending on JavaScript or Python behaviour.
                        Array indexing is defined in terms of array slicing.</t>

                     <t>A slice expression selects a subset of the elements of the input array, in the same order
                        as the array or the reverse order, depending on the sign of the <tt>step</tt> parameter.
                        It selects no nodes from a node which is not an array.</t>

                     <t>A slice is defined by the two slice parameters, <tt>start</tt> and <tt>end</tt>,
                        and an iteration delta, <tt>step</tt>. Each of these parameters is optional.
                        <tt>len</tt> is the length of the input array.</t>

                     <t>The default value for <tt>step</tt> is <tt>1</tt>.
                        The default values for <tt>start</tt> and <tt>end</tt> depend on the sign of <tt>step</tt>,
                        as follows:</t>

                     <table>
                       <name>Default array slice start and end values</name>
                       <thead>
                         <tr> <th>Condition</th>    <th>start</th>   <th>end</th> </tr>
                       </thead>
                       <tbody>
                         <tr> <td>step &gt;= 0</td> <td>0</td>       <td>len</td> </tr>
                         <tr> <td>step &lt; 0</td>  <td>len - 1</td> <td>-len - 1</td> </tr>
                       </tbody>
                     </table>

                     <t>Slice expression parameters <tt>start</tt> and <tt>end</tt> are not directly usable
                        as slice bounds and must first be normalized. Normalization is defined as:</t>

                     <sourcecode type="pseudocode">
FUNCTION Normalize(i):
  IF i &gt;= 0 THEN
    RETURN i
  ELSE
    RETURN len + i
  END IF
                     </sourcecode>

                     <t>The result of the array indexing expression <tt>[i]</tt> is defined to be the result of the array
                        slicing expression <tt>[i:Normalize(i)+1:1]</tt>.</t>

                     <t>Slice expression parameters <tt>start</tt> and <tt>end</tt> are used to derive slice bounds
                        <tt>lower</tt> and <tt>upper</tt>. The direction of the iteration, defined
                        by the sign of <tt>step</tt>, determines which of the parameters is the lower bound and which
                        is the upper bound:</t>

                     <sourcecode type="pseudocode">
FUNCTION Bounds(start, end, step, len):
  n_start = Normalize(start)
  n_end = Normalize(end)

  IF step &gt;= 0 THEN
    lower = MIN(MAX(n_start, 0), len)
    upper = MIN(MAX(n_end, 0), len)
  ELSE
    upper = MIN(MAX(n_start, -1), len-1)
    lower = MIN(MAX(n_end, -1), len-1)
  END IF

  RETURN (lower, upper)
</sourcecode>

                     <t>The slice expression selects elements with indices between the lower and upper bounds.
                        In the following pseudocode, the <tt>a(i)</tt> construct expresses the
                        0-based indexing operation on the underlying array.</t>

                     <sourcecode type="pseudocode">
IF step &gt; 0 THEN

  i = lower
  WHILE i &lt; upper:
    SELECT a(i)
    i = i + step
  END WHILE

ELSE if step &lt; 0 THEN

  i = upper
  WHILE lower &lt; i:
    SELECT a(i)
    i = i + step
  END WHILE

END IF
                     </sourcecode>

                     <t>When <tt>step = 0</tt>, no elements are selected and the result array is empty.</t>

                     <t>An implementation MUST raise an error if any of the slice expression parameters does not fit in
                        the implementation's representation of an integer.
                        If a successfully parsed slice expression is evaluated against an array whose size doesn't
                        fit in the implementation's representation of an integer, the implementation
                        MUST raise an error.</t>

                  </section>
               </section>
            </section>
         </section>
   </section>
   <section anchor="IANA" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>This memo includes no request to IANA.</t>
      <t>All drafts are required to have an IANA considerations section (see
     <xref target="RFC5226" format="default">Guidelines for Writing an IANA Considerations Section in RFCs</xref> for a guide). If the draft does not require IANA to do
     anything, the section contains an explicit statement that this is the
     case (as above). If there are no requirements for IANA, the section will
     be removed during conversion into an RFC by the RFC Editor.</t>
    </section>
    <section anchor="Security" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>This section gives security considerations, as required by <xref target="RFC3552" format="default">RFC&nbsp;3552</xref>.</t>
    </section>
   <section anchor="Alternatives" numbered="true" toc="default">
      <name>Alternatives</name>
      <t>An analogous standard, JSON Pointer, is provided by <xref target="RFC6901" format="default">RFC&nbsp;6901</xref>.</t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

 <back>
   <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <?rfc include="reference.RFC.2119.xml"?>
        <?rfc include="reference.RFC.3629.xml"?>
        <?rfc include="reference.RFC.5234.xml"?>
      </references>
      <references>
        <name>Informative References</name>
        <?rfc include="reference.RFC.3552.xml"?>
        <?rfc include="reference.RFC.5226.xml"?>
        <?rfc include="reference.RFC.6901.xml"?>
        <?rfc include="reference.RFC.8259.xml"?>
        <reference anchor="Goessner" target="https://goessner.net/articles/JsonPath/">
          <front>
            <title>JSONPath - XPath for JSON</title>
            <author>
              <organization>Stefan Gössner</organization>
            </author>
            <date year="2007" month="February"/>
          </front>
        </reference>
        <reference anchor="ECMA-262" target="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf">
          <front>
            <title>ECMAScript Language Specification, Standard ECMA-262, Third Edition</title>
            <author>
              <organization>Ecma International</organization>
            </author>
            <date year="1999" month="December"/>
          </front>
        </reference>
       </references>
    </references>
 </back>
</rfc>
